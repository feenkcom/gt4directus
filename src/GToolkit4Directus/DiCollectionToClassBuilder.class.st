"
I build a class model hierarchy based on ${class:DiMetaCollections}$.

!! Example

The following company meta-model ${example:DiExamples>>#metaCollectionsOfCompany|codeExpanded=false|previewExpanded=true}$

can be generated by executing the following example: ${example:DiExamples>>#buildCompanyModel}$


"
Class {
	#name : #DiCollectionToClassBuilder,
	#superclass : #Object,
	#instVars : [
		'collections',
		'package',
		'packageTag',
		'obsoletePackageTag',
		'modelClassPrefix',
		'modelRootClass',
		'jsonMappingClass',
		'extensions'
	],
	#category : #'GToolkit4Directus-Builder'
}

{ #category : #deprecation }
DiCollectionToClassBuilder class >> isDeprecated [
	^ true
]

{ #category : #accessing }
DiCollectionToClassBuilder >> addExtension: anExtension [
	self 
		assert: [ anExtension isNotNil ] 
		description: [ 'The builder extension must be non-nil' ].
	anExtension builder: self.
	self extensions add: anExtension
]

{ #category : #building }
DiCollectionToClassBuilder >> build [
	| theModelCollections |
	theModelCollections := self collections reject: #isSystemCollection.
	theModelCollections ifEmpty: [ ^ self ].
	EpMonitor current disable. 
	[ 
		self makeOldModelObsolete.
		self buildModels: theModelCollections.
		self compileJsonMappingMainReadingMethod: theModelCollections.
		self buildUsingExtensions 
	] ensure: [ EpMonitor current enable ].
]

{ #category : #'compiling - class' }
DiCollectionToClassBuilder >> buildClassDefinition: aClassName slots: theSlots [
	^ self class environment 
		at: aClassName asSymbol
		ifPresent: [ :theClass | self updateClassDefinition: theClass slots: theSlots ]
		ifAbsent: [ self compileClassDefinition: aClassName slots: theSlots ]
]

{ #category : #building }
DiCollectionToClassBuilder >> buildModel: aDiMetaCollection [
	| aClassName theSlots aClass |
	aClassName := self collectionPrefixAndClassName: aDiMetaCollection.
	theSlots := self collectionSlots: aDiMetaCollection.
	aClass := self buildClassDefinition: aClassName slots: theSlots.
	self compileClass: aClass collectionName: aDiMetaCollection name.
	self compileClass: aClass accessors: theSlots.
	self
		compileJsonMappingForModelOf: aDiMetaCollection
		class: aClass
		accessors: theSlots.
	self
		compileJsonMappingForCollectionOf: aDiMetaCollection
		class: aClass.
	self compileJsonMappingForDataOf: aDiMetaCollection class: aClass
]

{ #category : #building }
DiCollectionToClassBuilder >> buildModels: theModelCollections [
	theModelCollections
		do: [ :eachCollection | self buildModel: eachCollection ]
]

{ #category : #building }
DiCollectionToClassBuilder >> buildUsingExtensions [
	self extensions
		do: [ :eachBuilderExtension | eachBuilderExtension build ]
]

{ #category : #'accessing - model' }
DiCollectionToClassBuilder >> collectionModelClassName: aDiMetaCollection [
	<return: #String>
	^ aDiMetaCollection modelClassName
]

{ #category : #'accessing - model' }
DiCollectionToClassBuilder >> collectionPrefixAndClassName: aDiMetaCollection [ 
	^ String streamContents: [ :aStream | 
		aStream 
			nextPutAll: self modelClassPrefix;
			nextPutAll: (self collectionModelClassName: aDiMetaCollection)
		]
]

{ #category : #'accessing - model' }
DiCollectionToClassBuilder >> collectionSlotName: aDiMetaField [ 
	^ aDiMetaField getter
]

{ #category : #'accessing - model' }
DiCollectionToClassBuilder >> collectionSlots: aDiMetaCollection [ 
	^ Array new: aDiMetaCollection numberOfFields streamContents: [ :aStream |
		aDiMetaCollection fields do: [ :eachField | 
			aStream nextPut: (self collectionSlotName: eachField) ] ]
]

{ #category : #accessing }
DiCollectionToClassBuilder >> collections [
	^ collections
]

{ #category : #accessing }
DiCollectionToClassBuilder >> collections: anObject [
	collections := anObject
]

{ #category : #'compiling - model' }
DiCollectionToClassBuilder >> compileClass: aClass accessors: theSlots [
	theSlots do: [ :eachSlotName | 
		aClass 
			compile: eachSlotName, String cr, String tab, '^ ', eachSlotName 
			classified: 'accessing'.
		aClass 
			compile: eachSlotName, ': anObject', String cr, String tab, eachSlotName, ':= anObject' 
			classified: 'accessing'.
		"Generate also printOn: if there is a slot called name.
		We likely wants this as a kind of builder extension (extra rules) in the future."
		(eachSlotName = 'name') ifTrue: [ 
			self compileClass: aClass printOnWithName: eachSlotName ].
	]
]

{ #category : #'compiling - model' }
DiCollectionToClassBuilder >> compileClass: aClass collectionName: aString [
	aClass class
		compile: 'collectionName', String cr, String tab, '^ #''', aString, ''''
		classified: 'accessing'.
]

{ #category : #'compiling - model' }
DiCollectionToClassBuilder >> compileClass: aClass printOnWithName: aSlotName [
	"Generate also printOn: if there is a slot called name.
	We likely wants this as a kind of builder extension (extra rules) in the future."
	aClass 
		compile: 'printOn: aStream', String cr, 
			String tab, 'self name ifNil: [ ^ super printOn: aStream ].', String cr,
			String tab, 'aStream nextPutAll: self name asString'
		classified: 'printing'.
]

{ #category : #'compiling - class' }
DiCollectionToClassBuilder >> compileClassDefinition: aClassName slots: theSlots [
	^ self modelRootClass
		subclass: aClassName asSymbol
		slots: theSlots
		classVariables: {}
		package: self packageTag categoryName
]

{ #category : #'compiling - json mapping' }
DiCollectionToClassBuilder >> compileJsonMappingClass [
	| aClass |
	aClass := Object 
		subclass: self modelClassPrefix, 'JsonMapping'
		slots: {  }
		classVariables: {  }
		package: self packageTag categoryName.
	aClass class 
		instanceVariableNames: 'uniqueInstance'.
	aClass class 
		compile: 'uniqueInstance
	^ uniqueInstance ifNil: [ uniqueInstance := self new ]' 
		classified: 'accessing'.
	aClass class 
		compile: 'resetUniqueInstance
	uniqueInstance := nil' 
		classified: 'cleanup'.
	aClass class 
		compile: 'cleanUp
	self resetUniqueInstance' 
		classified: 'cleanup'.
	^ aClass
]

{ #category : #'compiling - json mapping' }
DiCollectionToClassBuilder >> compileJsonMappingForCollectionOf: aDiMetaCollection class: aClass [ 
	| aJsonMappingClass aMethodBody |
	aJsonMappingClass := self jsonMappingClass.
	aMethodBody := String streamContents: [ :aStream | 
		aStream 
			nextPutAll: 'collectionOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: 'For: aNeoJSONMapper'; cr;
			tab; nextPutAll: 'aNeoJSONMapper'; cr;
			tab; tab; nextPutAll: 'for: '; nextPutAll: '#CollectionOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: ' customDo: [ :mapping |'; cr;
			tab; tab; tab; nextPutAll: 'mapping listOfElementSchema: '; nextPutAll: aClass name; nextPutAll: ' ].'; cr";
			tab; nextPutAll: 'self mappingOf'; nextPutAll: aClass name; nextPutAll: 'For: aNeoJSONMapper.'; cr" ].
	aJsonMappingClass compile: aMethodBody classified: 'mappings - collections'.
]

{ #category : #'compiling - json mapping' }
DiCollectionToClassBuilder >> compileJsonMappingForDataOf: aDiMetaCollection class: aClass [ 
	| aJsonMappingClass aMethodBody |
	aJsonMappingClass := self jsonMappingClass.
	aMethodBody := String streamContents: [ :aStream | 
		aStream 
			nextPutAll: 'dataOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: 'For: aNeoJSONMapper'; cr;
			tab; nextPutAll: 'aNeoJSONMapper'; cr;
			tab; tab; nextPutAll: 'for: '; nextPutAll: '#DataOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: ' customDo: [ :mapping |'; cr;
			tab; tab; tab; nextPutAll: 'mapping reader: [ :jsonReader | '; cr;
			tab; tab; tab; tab; nextPutAll: '| aResult |'; cr;
			tab; tab; tab; tab; nextPutAll: 'jsonReader parseMapDo: ['; cr;
			tab; tab; tab; tab; tab; nextPutAll: '(jsonReader parsePropertyName asString = ''data'')'; cr;
			tab; tab; tab; tab; tab; tab; nextPutAll: 'ifTrue: ['; cr;
			tab; tab; tab; tab; tab; tab; tab; nextPutAll: 'jsonReader expectChar: $:.'; cr;
			tab; tab; tab; tab; tab; tab; tab; nextPutAll: 'aResult := jsonReader nextAs: #CollectionOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: ' ]'; cr;
			tab; tab; tab; tab; tab; tab; nextPutAll: 'ifFalse: ['; cr;
			tab; tab; tab; tab; tab; tab; tab; nextPutAll: 'jsonReader expectChar: $:.'; cr;
			tab; tab; tab; tab; tab; tab; tab; nextPutAll: 'aResult := jsonReader next ] ].'; cr;
			tab; tab; tab; tab; nextPutAll: 'aResult ].'; cr;
			tab; tab; tab; nextPutAll: 'mapping writer: [ :jsonWriter :list |'; cr;
			tab; tab; tab; tab; nextPutAll: 'self error: ''Writer not supported'' ] ]'; cr ].
	aJsonMappingClass compile: aMethodBody classified: 'mappings - data'.
	

]

{ #category : #'compiling - json mapping' }
DiCollectionToClassBuilder >> compileJsonMappingForModelOf: aDiMetaCollection class: aClass accessors: theSlots [ 
	| aJsonMappingClass aMethodBody |
	aJsonMappingClass := self jsonMappingClass.
	aMethodBody := String streamContents: [ :aStream | 
		aStream 
			nextPutAll: 'mappingOf'; nextPutAll: (self collectionModelClassName: aDiMetaCollection); nextPutAll: 'For: aNeoJSONMapper'; cr;
			tab; nextPutAll: 'aNeoJSONMapper'; cr;
			tab; tab; nextPutAll: 'for: '; nextPutAll: aClass name; nextPutAll: ' do: [ :mapping |'; cr.
		aDiMetaCollection fields paddedWith: theSlots do: [ :eachField :eachSlot | 
			aStream
				tab; tab; tab; nextPutAll: 'mapping mapAccessor: #'; nextPutAll: eachSlot; nextPutAll: ' to: #'; nextPutAll: eachField name; nextPut: $.; cr ].
		aStream
				tab; tab; nextPutAll: '].' ].
	aJsonMappingClass compile: aMethodBody classified: 'mappings - models'.
]

{ #category : #'compiling - json mapping' }
DiCollectionToClassBuilder >> compileJsonMappingMainReadingMethod: aDiMetaCollections [ 
	| aJsonMappingClass aMethodBody |
	aJsonMappingClass := self jsonMappingClass.
	aMethodBody := String streamContents: [ :aStream | 
		aStream 
			nextPutAll: 'read: aJsonSchema on: aReadStream'; cr;
			tab; nextPutAll: '| aReader |'; cr;
			tab; nextPutAll: 'aReader := (NeoJSONReader on: aReadStream).'; cr.
		aDiMetaCollections do: [ :eachMetaCollection | 
			eachMetaCollection isSystemCollection ifFalse: [ 
				| aClassName |
				aClassName := self collectionModelClassName: eachMetaCollection.
				aStream
					tab; nextPutAll: 'self '; nextPutAll: 'mappingOf'; nextPutAll: aClassName; nextPutAll: 'For: aReader.'; cr;
					tab; nextPutAll: 'self '; nextPutAll: 'collectionOf'; nextPutAll: aClassName; nextPutAll: 'For: aReader.'; cr;
					tab; nextPutAll: 'self '; nextPutAll: 'dataOf'; nextPutAll: aClassName; nextPutAll: 'For: aReader.'; cr ] ].
		aStream
				tab; nextPutAll: '^ aReader nextAs: aJsonSchema.'; cr ].
	aJsonMappingClass compile: aMethodBody classified: 'reading'.
]

{ #category : #'compiling - model' }
DiCollectionToClassBuilder >> compileModelRootClass [
	| aClass |
	aClass := Object 
		subclass: self modelClassPrefix, 'Model'
		slots: {  }
		classVariables: {  }
		package: self packageTag categoryName.
	aClass 
		compile: 'collectionName', String cr, String tab, '^ self class collectionName'
		classified: 'accessing'.
	aClass class
		compile: 'collectionName', String cr, String tab, '^ self subclassResponsibility'
		classified: 'accessing'.
	^ aClass
]

{ #category : #'compiling - package' }
DiCollectionToClassBuilder >> compileObsoletePackageTag [
	<return: #RPackageTag>
	| aPackage |
	aPackage := self package.
	^ aPackage classTagNamed: self defaultObsoletePackageTagName ifAbsent: [ aPackage addClassTag: self defaultObsoletePackageTagName ].
	
]

{ #category : #'compiling - package' }
DiCollectionToClassBuilder >> compilePackageTag [
	<return: #RPackageTag>
	| aPackage |
	aPackage := self package.
	^ aPackage classTagNamed: self defaultPackageTagName ifAbsent: [ aPackage addClassTag: self defaultPackageTagName ].
	
]

{ #category : #defaults }
DiCollectionToClassBuilder >> defaultObsoletePackageTagName [
	^ #'! Obsolete Model'
]

{ #category : #defaults }
DiCollectionToClassBuilder >> defaultPackageTagName [
	^ #'Model'
]

{ #category : #accessing }
DiCollectionToClassBuilder >> extensions [
	^ extensions
]

{ #category : #accessing }
DiCollectionToClassBuilder >> extensions: anObject [
	extensions := anObject
]

{ #category : #initialization }
DiCollectionToClassBuilder >> initialize [
	super initialize.
	collections := nil.
	extensions := OrderedCollection new.
	jsonMappingClass := nil.
	modelClassPrefix := nil.
	modelRootClass := nil.
	obsoletePackageTag := nil.
	package := nil.
	packageTag := nil.
]

{ #category : #accessing }
DiCollectionToClassBuilder >> jsonMappingClass [
	^ jsonMappingClass ifNil: [ jsonMappingClass := self compileJsonMappingClass ]
]

{ #category : #accessing }
DiCollectionToClassBuilder >> jsonMappingClass: aClass [
	jsonMappingClass := aClass
]

{ #category : #'compiling - package' }
DiCollectionToClassBuilder >> makeOldModelObsolete [
	| aPackageTag anObsoletePackageTag |
	aPackageTag := self packageTag.
	aPackageTag isEmpty ifTrue: [ ^ self ].
	anObsoletePackageTag := self obsoletePackageTag.
	aPackageTag classes do: [ :eachClass |
		eachClass tagWith: anObsoletePackageTag name ].
]

{ #category : #accessing }
DiCollectionToClassBuilder >> modelClassPrefix [
	<return: #String>
	^ modelClassPrefix ifNil: [ 'DiMo' ]
]

{ #category : #accessing }
DiCollectionToClassBuilder >> modelClassPrefix: anObject [
	modelClassPrefix := anObject
]

{ #category : #accessing }
DiCollectionToClassBuilder >> modelRootClass [
	^ modelRootClass ifNil: [ modelRootClass := self compileModelRootClass ].
]

{ #category : #accessing }
DiCollectionToClassBuilder >> modelRootClass: anObject [
	modelRootClass := anObject
]

{ #category : #accessing }
DiCollectionToClassBuilder >> obsoletePackageTag [
	^ obsoletePackageTag ifNil: [ obsoletePackageTag := self compileObsoletePackageTag ]
]

{ #category : #accessing }
DiCollectionToClassBuilder >> obsoletePackageTag: anObject [
	obsoletePackageTag := anObject
]

{ #category : #accessing }
DiCollectionToClassBuilder >> package [
	^ package
]

{ #category : #accessing }
DiCollectionToClassBuilder >> package: aRPackage [
	package := aRPackage
]

{ #category : #accessing }
DiCollectionToClassBuilder >> packageTag [
	^ packageTag ifNil: [ packageTag := self compilePackageTag ]
]

{ #category : #accessing }
DiCollectionToClassBuilder >> packageTag: anObject [
	packageTag := anObject
]

{ #category : #'compiling - class' }
DiCollectionToClassBuilder >> updateClassDefinition: aClass slots: theSlots [
	aClass tagWith: self packageTag categoryName.
	theSlots sorted asArray = aClass instVarNames sorted asArray ifTrue: [ ^ aClass ].
	theSlots do: [ :eachSlotName | 
		(aClass definesSlotNamed: eachSlotName) ifFalse: [
			aClass addInstVarNamed: eachSlotName ] ].
	aClass instVarNames do: [ :eachVarName | 
		(theSlots includes: eachVarName) ifFalse: [
			aClass removeInstVarNamed: eachVarName ] ].
	^ aClass
]
